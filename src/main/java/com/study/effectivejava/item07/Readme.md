# 아이템 7: 더이상 쓰지 않는 객체 레퍼런스는 없애자

## 메모리 직접 관리

자바에 GC (가비지 콜렉터)가 있기 때문에 메모리 관리에 대해 신경쓰지 않아도 될거라고 생각하기 쉽지만 그렇지 않다. 다음 코드를 살펴보자.



스택에 계속 쌓다가 많이 빼냈다고 치자, 그래도 스택이 차지하고 있는 메모리는 줄어들지 않는다. 왜냐면 저 스택의 구현체는 필요없는 객체에 대한 레퍼런스를 그대로 가지고 있기 때문이다. 가용한 범위는 `size` 보다 작은 부분이고 그 값 보다 큰 부분에 있는 값들은 필요없이 메모리를 차지하고 있는 부분이다.


**`메모리를 직접 관리하는 클래스`는 프로그래머가 메모리 누수를 조심해야 한다.**

- Ex) Stack

- 스택의 사이즈가 커졌다가 줄어들 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다.

- 스택의 경우 pop을 해도 스택에서 여전히 사용이 끝난 참조값(obsolete reference)을 갖고 있다.

- 이를 비활성 영역이라고도 할 수 있으며 가비지 컬렉터는 비활성 영역이 사용하지 않는 레퍼런스라는 것을 알 방법이 없다.

- 여기서 문제는 다 쓴 레퍼런스 값의 메모리 누수 외에도 해당 객체가 참조하고 있는 모든 객체(그리고 그 객체가 참조하는 모든 객체)를 가비지 컬렉터가 회수 할 수 없어서 추가적인 메모리 누수가 발생한다.

## GC(가비지 컬렉터)
주기적으로 JVM의 heap 메모리를 점검하여 스택에서 참조되지 않는 객체를 메모리에서 해제하는 장치이다.

## 캐시

캐시를 사용할 때도 메모리 누수 문제를 조심해야 한다. 객체의 레퍼런스를 캐시에 넣어 놓고 캐시를 비우는 것을 잊기 쉽다. 여러 가지 해결책이 있지만, **캐시의 키**에 대한 레퍼런스가 캐시 밖에서 필요 없어지면 해당 엔트리를 캐시에서 자동으로 비워주는 `WeakHashMap`을 쓸 수 있다.

또는 특정 시간이 지나면 캐시값이 의미가 없어지는 경우에 백그라운드 쓰레드를 사용하거나 (아마도 `ScheduledThreadPoolExecutor`), 새로운 엔트리를 추가할 때 부가적인 작업으로 기존 캐시를 비우는 일을 할 것이다. (`LinkedHashMap` 클래스는 `removeEldestEntry`라는 메서드를 제공한다.)

## 콜백

세번째로 흔하게 메모리 누수가 발생할 수 있는 지점으로 리스너와 콜백이 있다.

클라이언트 코드가 콜백을 등록할 수 있는 API를 만들고 콜백을 뺄 수 있는 방법을 제공하지 않는다면, 계속해서 콜백이 쌓이기 할 것이다. 이것 역시 `WeahHashMap`을 사용해서 해결 할 수 있다.

메모리 누수는 발견하기 쉽지 않기 때문에 수년간 시스템에 머물러 있을 수도 있다. 코드 인스택션이나 `heap profiler` 같은 디버깅 툴을 사용해서 찾아야 한다. 따라서 이런 문제를 예방하는 방법을 학습하여 미연에 방지하는 것이 좋다.

## 참고

* [Weak 레퍼런스](https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html)
